#!/usr/bin/env python
# -*- coding: utf-8 -*-

from tensorflow.examples.tutorials.mnist import input_data
import tensorflow as tf

# import data
import numpy as np
import random
import time

class NeuralNetwork(object):

    def __init__(self):
        #self.mnist = input_data.read_data_sets("MNIST_data/", one_hot=True)
        self.ACTIONS = 6 # number of valid actions
        self.INITIAL_EPSILON = 1.0 # starting value of epsilon
        #data設計
        #inputdataの種類：体力度, 空腹度, 食欲,　睡眠欲, 性欲, 労働欲, 喜, 怒, 哀, 楽
        #outputdataの種類：※一旦１０種類(0と1のbit)
        #parameter幅：1ターン毎
        #data幅：0.0 ~ 1.0(float)
        self.game_parameter = []
        for i in range(1,100) :
            a_param = []
            for j in range(1,10) :
                a_param.append(random.random())

            self.game_parameter.append(a_param)
        #print(self.game_parameter)


    def weight_variable(self, shape):
        initial = tf.truncated_normal(shape, stddev = 0.01)
        return tf.Variable(initial)

    def bias_variable(self, shape):
        initial = tf.constant(0.01, shape = shape)
        return tf.Variable(initial)

    def createNetwork(self):
        # network weights
        W_conv1 = self.weight_variable([10, 36])
        b_conv1 = self.bias_variable([36])

        W_conv2 = self.weight_variable([36, 36])
        b_conv2 = self.bias_variable([36])

        W_fc1 = self.weight_variable([36, 10])
        b_fc1 = self.bias_variable([10])

        W_fc2 = self.weight_variable([10, self.ACTIONS])
        b_fc2 = self.bias_variable([self.ACTIONS])

        # input layer
        s = tf.placeholder(tf.float32, [None, 10])

        # hidden layers
        h_conv1 = tf.nn.relu(tf.matmul(s, W_conv1) + b_conv1)
        h_conv2 = tf.nn.relu(tf.matmul(h_conv1, W_conv2) + b_conv2)
        h_fc1 = tf.nn.relu(tf.matmul(h_conv2, W_fc1) + b_fc1)

        # readout layer
        readout = tf.matmul(h_fc1, W_fc2) + b_fc2

        return s, readout, h_fc1

    def trainNetwork(self, a_parameter, s, readout, h_fc1, sess):
        # define the cost function
        a = tf.placeholder("float", [None, self.ACTIONS])
        y = tf.placeholder("float", [None])
        readout_action = tf.reduce_sum(tf.multiply(readout, a), reduction_indices = 1)
        cost = tf.reduce_mean(tf.square(y - readout_action))
        train_step = tf.train.AdamOptimizer(1e-6).minimize(cost)

        print(a_parameter)

    def playGame(self):
        sess = tf.InteractiveSession()
        s, readout, h_fc1 = self.createNetwork()
        for a_parameter in self.game_parameter:
            time.sleep(1)
            self.trainNetwork(a_parameter, s, readout, h_fc1, sess)

    def main(self):
        self.playGame()


if __name__ == "__main__":
    nn = NeuralNetwork()
    nn.main()
